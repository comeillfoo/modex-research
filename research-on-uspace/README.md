# Исследование возможности инструмента modex к извлечению модели из примеров

## Notes. Заметки

TODO

## Report. Отчет о проделанной работе

С целью обеспечить воспроизводимость дальнейших результатов был составлен
`Makefile` для системы сборки `make`, в котором записаны шаги, требуемые для
извлечения модели из проекта и какие опции были использованы для каждой из
использованных утилит. Так, например, при вызове `modex` передаются
дополнительные опции, указывающие где искать заголовочные файлы при обработке
исходных файлов проекта. Также опциями понадобилось задать как интерпретировать
утилите некоторые пользовательские типы данных: `size_t`, `socklen_t`, `time_t`,
`FILE` и т.п. Для упрощения конечной модели решено было интерпретировать все
такие типы как знаковые 32-битные целые числа (`int`).

Дабы извлечь модель из кода проекта требовалось составить таблицу поиска (`LUT`).
В руководствах по `modex` указано, что можно гибко переключаться между разными
таблицами при извлечении каждой функции с помощью опций, однако на современных
системах они не работают, и таблицы поиска переключаются только после повторного
указания опции. Либо указать имя таблицы по умолчанию &mdash; `none.lut`.

Во время заполнения одной такой таблицы было замечено, что есть несколько
вариантов ее написания: либо замена целыми строками на этапе пост-обработки
модели, либо замена базовых конструкций. Второй способ более универсальный и
устойчивый к изменениям в исходном коде, однако и более подвержен ошибкам, так
как труднее отследить какие правила были применены на конкретном участке кода,
что может привести к регрессу, ввиду непреднамеренных трансляций кода на Си в
модель на Promela. А первый &mdash; проще и лучше позволяет контролировать
процесс извлечения, так как буквально сводит его к построчной трансляции одного
языка в другой.

Также было отмечено, что простота `LUT` зависит от цели извлечения модели. `Modex`
позволяет извлечь только часть кода с целью проверки локальных инвариантов (не
наш случай). Данный вариант подразумевает, что большая часть переменных, не
использующихся для проверки, просто удаляется из модели директивой `NonState`
(не показывает состояние модели) а участки кода, взаимодействующие с ними,
заменяются директивой `Substitute` на "пустые" операторы (в Promela &mdash;
`skip`).

При составлении `LUT` для `netcat` директивы `NonState` и `Substitute`
использовались в основном для исключения глобальных переменных, отвечающих за
тонкую настройку утилиты (они же опции командной строки): использование TLS,
telnet, zero-copy TCP и т.п. Или же для замен на константные выражения: `false`
или `true` &mdash; как например для опции `-l`, которая указывает режим работы:
клиент или сервер.

Другая сложность, возникшая в ходе работы, это правильный перенос абстракций
ввода-вывода языка Си на конструкции Promela. Например, в утилите `netcat`, для
обозначения закрытого файлового дескриптора переменной присваивается `-1`, что
нельзя напрямую перенести на буферизованные каналы в Promela. Поэтому были введены
флаги, сигнализирующие о закрытии файлового дескриптора. Аналогично конечная
емкость каналов по сравнению с "бесконечным" буфером у файловых дескрипторов
была эмулирована с помощью указания достаточно большой емкости у каналов, дабы
всегда была возможность записать в них данные без блокировки.

Модели на Promela не допускают ввода от пользователя, в отличие от утилиты
`netcat`, которая и предназначена для отправки данных со стандартного потока
ввода. Поэтому при извлечении модели были созданы дополнительные заглушки,
эмулирующие ввод от пользователя конкретных текстовых строк.

По итогу, был составлен файл, позволяющий извлекать модель сервера и клиента,
взаимодействующих по протоколу TCP, на основе алгоритма работы конкретной версии
утилиты `netcat`, который можно в дальнейшем дорабатывать для проверки конкретных
свойств и инвариантов, и исходный код которого можно найти в &laquo;Приложение 1.
Указаниями по извлечению модели из кода утилиты `netcat`&raquo;.
